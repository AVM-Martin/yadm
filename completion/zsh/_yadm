#compdef yadm

# This completion tries to fallback to git's completion for git commands.
# It handles two different types of fallbacks:
#  - The git completion shipped with git.
#  - The git completion shipped with zsh.

_yadm-alt() {
    return 0
}

_yadm-bootstrap() {
    return 0
}

_yadm-clone() {
    _arguments \
        '(--bootstrap --no-bootstrap)--bootstrap[force bootstrap, without prompt]' \
        '(--bootstrap --no-bootstrap)--no-bootstrap[prevent bootstrap, without prompt]' \
        '-b[branch name]:' \
        '-f[force overwrite of existing repository]' \
        '-w[work tree path]: :_files -/' \
        '*:'
}

_yadm-config() {
    # TODO: complete config names
}

_yadm-decrypt() {
    _arguments \
        '-l[list files]'
}

_yadm-encrypt() {
    return 0
}

_yadm-enter() {
    _arguments \
        ':command: _command_names -e' \
        '*::arguments: _normal'
}

_yadm-git-crypt() {
    # TODO: complete git-crypt options
}

_yadm-help() {
    return 0
}

_yadm-init() {
    _arguments \
        '-f[force overwrite of existing repository]' \
        '-w[work tree path]: :_files -/'
}

_yadm-list() {
    _arguments \
        '-a[list all tracked files]'
}

_yadm-perms() {
    return 0
}

_yadm-transcrypt() {
    integer _ret=1
    _call_function _ret _transcrypt
    return _ret
}

_yadm-upgrade() {
    return 0
}

_yadm-version() {
    return 0
}

_yadm_commands() {
    local -a commands
    commands=(
        alt:'create links for alternates (yadm)'
        bootstrap:'execute bootstrap (yadm)'
        clone:'clone an existing repository (yadm)'
        config:'configure an yadm setting'
        decrypt:'decrypt files (yadm)'
        encrypt:'encrypt files (yadm)'
        enter:'run sub-shell with GIT variables set'
        git-crypt:'run git-crypt commands for the yadm repository'
        gitconfig:'run the git config command'
        help:'display yadm help information'
        init:'initialize an empty yadm repository'
        list:'list files tracked by yadm'
        perms:'fix perms for private files (yadm)'
        transcrypt:'run transcrypt commands for the yadm repository'
        upgrade:'upgrade legacy yadm paths'
        version:'show yadm version'
    )

    integer _ret=1

    if (( $+functions[_git_commands] )); then
        zstyle ':completion:*:*:yadm:*' user-commands $commands
        _call_function _ret _git_commands
        zstyle -d ':completion:*:*:yadm:*' user-commands
    else
        local curcontext=${curcontext%:*:*}:git:
        _tags common-commands alias-commands all-commands
        while _tags; do
            _requested common-commands && __git_zsh_cmd_common
            _requested alias-commands && __git_zsh_cmd_alias
            _requested all-commands && __git_zsh_cmd_all
            let _ret || break
        done
        _describe "yadm commands" commands
    fi

    return _ret
}

_yadm() {
    local curcontext=$curcontext state state_descr line
    declare -A opt_args

    local -a orig_words=( ${words[@]} )
    local cur=${words[CURRENT]}
    local prev=${words[CURRENT-1]}
    let cword=CURRENT-1

    _arguments -C \
      '(-Y --yadm-dir)'{-Y,--yadm-dir}'[override the standard yadm directory]: :_files -/' \
      '--yadm-data[override the standard yadm data directory]: :_files -/' \
      '--yadm-repo[override the standard repo path]: :_files -/' \
      '--yadm-config[override the standard config path]: :_files -/' \
      '--yadm-encrypt[override the standard encrypt path]: :_files -/' \
      '--yadm-archive[override the standard archive path]: :_files -/' \
      '--yadm-bootstrap[override the standard bootstrap path]: :_files' \
      '--help[display yadm help information]' \
      '--version[show yadm version]' \
      '(-): :->command' \
      '(-)*:: :->option-or-argument' && return

    local -a repo_args
    (( $+opt_args[--yadm-repo] )) && repo_args+=(--yadm-repo "$opt_args[--yadm-repo]")
    (( $+opt_args[--yadm-data] )) && repo_args+=(--yadm-data "$opt_args[--yadm-data]")
    local -x GIT_DIR="$(_call_program gitdir yadm "${repo_args[@]}" introspect repo)"
    local __git_dir="$GIT_DIR"

    integer _ret=1
    case $state in
        (command)
            _yadm_commands && _ret=0
            ;;
        (option-or-argument)
            local command=$words[1]

            # First try to complete yadm commands
            curcontext=${curcontext%:*:*}:yadm-$command:
            if ! _call_function _ret _yadm-$command; then
                # Translate gitconfig to use the regular completion for config
                [[ $command = "gitconfig" ]] && command=config

                # If is wasn't a valid command, try git's completion if available
                if (( $+functions[__git_zsh_bash_func] )); then
                    words=( ${orig_words[@]} )
                    curcontext=${curcontext%:*:*}:git:

                    __git_zsh_bash_func $command
                    let _ret && _default && _ret=0
                else
                    # If git's completion wasn't available, try zsh's
                    curcontext=${curcontext%:*:*}:git-$command:
                    if ! _call_function _ret _git-$command; then
                        if [[ $words[1] = \!* ]]; then
                            words[1]=${words[1]##\!}
                            _normal && _ret=0
                        elif zstyle -T :completion:$curcontext: use-fallback; then
                            _default && _ret=0
                        else
                            _message "unknown sub-command: $command"
                        fi
                    fi
                fi
            fi
            ;;
    esac

    return _ret
}

# Ignore call from _git when using git's completion
__yadm_zsh_main() {
    _ret=0
}

# __git_zsh_bash_func comes from git's completion and _git_commands from zsh's
(( $+functions[__git_zsh_bash_func] + $+functions[_git_commands] )) || _git
_yadm
